设计模式
可分为三大类
    创建型
    单例、简单工厂|工厂|抽象工厂、原型、建造者
    结构型
    外观、适配器、代理、装饰、组合、桥接、亨元[可以理解为缓存共享对象]
    行为型
    模板、策略、命令、状态、职责链、迭代器、观察者、访问者、中介者、解释器、备忘录
    
=========================== 创建型 ===========================  
单例
   全局只有一个该实例
   构造方法私有化
   静态内部类，防止重排序
   选择关键点：一个对象在应用中出现多个是否会引起逻辑上的错误
   相关设计模式：原型模式，每次拷贝都生成一个实例，单例只生成一个
简单工厂
    工厂方法对传入参数进行判断，然后决定创建具体的对象
工厂方法
    工厂接口化，具体的创建在工厂子类中实现
抽象工厂
    创建多种类产品
    工厂接口化，具体的创建在工厂子类中实现
    1，首先从简单工厂进化到工厂方法，是因为工厂方法弥补了简单工厂对修改开放的弊端，即简单工厂违背了开闭原则。
    2，从工厂方法进化到抽象工厂，是因为抽象工厂弥补了工厂方法只能创造一个系列的产品的弊端。
原型模式
    浅拷贝，如果要深拷贝，需要引用对象实现cloneable接口
    一般是调用super.clone() 然后强转
建造者
    创建对象的步骤固定，创建细节不同
    创建接口 指挥者接口-指定创建顺序
    
=========================== 结构型 ===========================  

外观模式
    为一类子系统提供对外统一的接口，简化接口的使用
适配器模式
    想复用现有的某些功能，但现有接口又不符合目标接口
代理模式
    收敛现有接口的功能
    对现有接口前后增加相应功能
装饰模式
    扩展现有接口功能
    一般是把现有对象传入装饰器对象，然后对其进行了功能扩展
 组合模式
    表达部分与整体的结构，操作部分与整体的接口一样
 桥接模式
    有多维度变化[一般两个，一个用接口扩展，一个用子类来扩展]
 亨元模式
    共享对象，一般通过工厂，共享的对象从map中获取，非共享则创建
   
=========================== 行为型 =========================== 

模板方法
    定义算法骨架，子类选择性的覆盖部分方法
策略模式
    封装一系列算法，可相互替换
状态模式
    状态不同，行为不同，把不同状态对应的行为封装起来，执行完相应的行为过后，会切换状态
命令模式
    命令的创建需要知道|关联命令的执行者 ，解耦命令的请求与执行
职责链模式
    请求的处理形成一条链，请求只需传递到链上即可
迭代器模式
    提供依次访问内部对象的接口
观察者模式
    订阅发布，一对多
访问者模式
    被访问的对象的元素类型固定，操作容易扩展
中介者模式
    
    